{
  "easy": [
    {
      "id": 1,
      "question": "Which command is used to install packages from a `package.json` file?",
      "options": ["npm start", "npm install", "npm run", "npm get"],
      "answer": "npm install",
      "explanation": "The `npm install` command is used to install all dependencies listed in your `package.json` file."
    },
    {
      "id": 2,
      "question": "What is the purpose of the `require()` function in Node.js?",
      "options": ["To define a new function", "To import modules", "To declare a variable", "To run a script"],
      "answer": "To import modules",
      "explanation": "The `require()` function is used to import and use modules (both built-in and external) in a Node.js application."
    },
    {
      "id": 3,
      "question": "What is Node.js built on?",
      "options": ["Java Virtual Machine", "Python Interpreter", "Google Chrome's V8 Engine", "Apache Server"],
      "answer": "Google Chrome's V8 Engine",
      "explanation": "Node.js is a JavaScript runtime built on the V8 engine, which compiles JavaScript code to machine code for fast execution."
    },
    {
      "id": 4,
      "question": "Which of these is a built-in Node.js module for handling file system operations?",
      "options": ["`http`", "`fs`", "`path`", "`os`"],
      "answer": "`fs`",
      "explanation": "The `fs` (File System) module provides methods for working with the file system, such as reading and writing files."
    },
    {
      "id": 5,
      "question": "What does `npm` stand for?",
      "options": ["Node Project Manager", "New Package Module", "Node Package Manager", "Network Package Manager"],
      "answer": "Node Package Manager",
      "explanation": "npm is the official package manager for Node.js, and it stands for Node Package Manager."
    },
    {
      "id": 6,
      "question": "How do you start a Node.js script from the command line?",
      "options": ["run my-script.js", "execute my-script.js", "node my-script.js", "start my-script.js"],
      "answer": "node my-script.js",
      "explanation": "The `node` command is used to execute a Node.js file from the terminal."
    },
    {
      "id": 7,
      "question": "Is Node.js single-threaded or multi-threaded?",
      "options": ["Single-threaded", "Multi-threaded", "It depends on the operating system", "It's a mix of both"],
      "answer": "Single-threaded",
      "explanation": "Node.js uses a single-threaded event loop to handle requests, making it non-blocking and efficient for I/O-heavy applications."
    },
    {
      "id": 8,
      "question": "Which global object in Node.js provides information about the current process?",
      "options": ["`global`", "`process`", "`os`", "`console`"],
      "answer": "`process`",
      "explanation": "The `process` object is a global that provides information about and control over the current Node.js process."
    },
    {
      "id": 9,
      "question": "Which file is used to specify project metadata and dependencies?",
      "options": ["`main.js`", "`index.html`", "`package.json`", "`app.js`"],
      "answer": "`package.json`",
      "explanation": "The `package.json` file acts as a manifest for your Node.js project, listing its name, version, and dependencies."
    },
    {
      "id": 10,
      "question": "What is an event-driven architecture?",
      "options": ["A way to write synchronous code", "A design pattern where functions are called randomly", "A system where events trigger code execution", "A method for database connections"],
      "answer": "A system where events trigger code execution",
      "explanation": "Event-driven programming uses events to trigger the execution of functions, which is the core of Node.js's non-blocking nature."
    }
  ],
  "medium": [
    {
      "id": 11,
      "question": "What is a 'stream' in Node.js?",
      "options": ["A data pipe for continuous data flow", "A type of database", "A module for creating animations", "A network connection protocol"],
      "answer": "A data pipe for continuous data flow",
      "explanation": "Streams are objects that allow you to read or write data in a continuous, sequential manner, handling data in chunks rather than all at once."
    },
    {
      "id": 12,
      "question": "What is a 'middleware' in Express.js?",
      "options": ["A function that only handles errors", "A function that is executed before a route handler", "A tool for creating a database schema", "A class for managing user sessions"],
      "answer": "A function that is executed before a route handler",
      "explanation": "Middleware functions in Express.js have access to the request and response objects and are used to perform tasks like authentication and logging before a request reaches its final destination."
    },
    {
      "id": 13,
      "question": "Explain the concept of 'non-blocking I/O' in Node.js.",
      "options": ["The program waits for I/O operations to finish", "The program cannot perform I/O operations", "The program executes other code while waiting for I/O to finish", "The program blocks other operations while I/O is in progress"],
      "answer": "The program executes other code while waiting for I/O to finish",
      "explanation": "Non-blocking I/O means that Node.js initiates an I/O operation and immediately moves on to execute other code, handling the result later via a callback or event."
    },
    {
      "id": 14,
      "question": "What is the difference between `global` and `window`?",
      "options": ["`global` is for browsers, `window` is for Node.js", "`global` is for Node.js, `window` is for browsers", "They are identical", "They are both used for file operations"],
      "answer": "`global` is for Node.js, `window` is for browsers",
      "explanation": "`global` is the global namespace object in Node.js, while `window` is the equivalent in web browsers."
    },
    {
      "id": 15,
      "question": "How do you handle asynchronous operations without using callbacks?",
      "options": ["`setInterval`", "`async/await` and `Promises`", "`for` loops", "`if/else` statements"],
      "answer": "`async/await` and `Promises`",
      "explanation": "Promises and the `async/await` syntax are modern ways to handle asynchronous operations, providing cleaner and more readable code than nested callbacks."
    },
    {
      "id": 16,
      "question": "What is the purpose of `module.exports` and `exports`?",
      "options": ["They are used for defining global variables", "They are used to export values from a module", "They are used for creating new files", "They are used for importing external packages"],
      "answer": "They are used to export values from a module",
      "explanation": "`module.exports` and `exports` are objects used to expose functionality from a Node.js module so that it can be imported by other files using `require()`."
    },
    {
      "id": 17,
      "question": "What is the purpose of `package-lock.json`?",
      "options": ["To lock the project to a single developer", "To provide an exact version of each dependency", "To specify a package's license", "To store the project's source code"],
      "answer": "To provide an exact version of each dependency",
      "explanation": "The `package-lock.json` file records the exact version, checksum, and location of every package installed, ensuring consistent builds across different environments."
    },
    {
      "id": 18,
      "question": "What is 'callback hell'?",
      "options": ["A bug that crashes the server", "A state where a function is called without a callback", "A situation with deeply nested callbacks", "An error handling pattern"],
      "answer": "A situation with deeply nested callbacks",
      "explanation": "Callback hell, also known as the 'Pyramid of Doom,' refers to the unmanageable nesting of callback functions that makes code difficult to read and maintain."
    },
    {
      "id": 19,
      "question": "How can you debug a Node.js application?",
      "options": ["`node --debug`", "`node --log`", "`node --trace`", "`node --inspect`"],
      "answer": "`node --inspect`",
      "explanation": "The `node --inspect` command enables the V8 inspector, which allows you to debug your Node.js application using tools like Chrome DevTools."
    },
    {
      "id": 20,
      "question": "What is the `cluster` module used for?",
      "options": ["To create multiple databases", "To manage user sessions", "To enable multi-core processing", "To compress files"],
      "answer": "To enable multi-core processing",
      "explanation": "The `cluster` module allows you to create child processes that share server ports, enabling a Node.js application to take advantage of multi-core systems and improve performance for CPU-intensive tasks."
    }
  ],
  "hard": [
    {
      "id": 21,
      "question": "Differentiate between `process.nextTick()` and `setImmediate()`.",
      "options": ["`nextTick` runs after the current operation, `setImmediate` runs in the next event loop phase.", "`nextTick` runs in a separate thread, `setImmediate` runs on the main thread.", "They are identical in function.", "`nextTick` is for timers, `setImmediate` is for I/O operations."],
      "answer": "`nextTick` runs after the current operation, `setImmediate` runs in the next event loop phase.",
      "explanation": "Both are asynchronous but `process.nextTick()` callbacks are executed before the event loop moves to the next phase, while `setImmediate()` callbacks are executed in the 'check' phase of the event loop."
    },
    {
      "id": 22,
      "question": "What is a 'Buffer' in Node.js?",
      "options": ["A type of error", "A temporary storage for binary data", "A tool for handling strings", "A data structure for numbers only"],
      "answer": "A temporary storage for binary data",
      "explanation": "The `Buffer` class is used to handle raw binary data. It is a fundamental part of Node.js's I/O operations, such as handling file streams and network packets."
    },
    {
      "id": 23,
      "question": "How does Node.js handle concurrency?",
      "options": ["By creating a new thread for each request", "By using a single-threaded event loop and non-blocking I/O", "By relying on the browser's multi-threading", "It cannot handle concurrency"],
      "answer": "By using a single-threaded event loop and non-blocking I/O",
      "explanation": "Node.js achieves concurrency by using a single thread to manage an event loop, which handles asynchronous operations without blocking the main thread, making it highly scalable."
    },
    {
      "id": 24,
      "question": "What is the purpose of `EventEmitter`?",
      "options": ["To handle network requests", "To read and write files", "To manage and emit events with listeners", "To manage sessions"],
      "answer": "To manage and emit events with listeners",
      "explanation": "The `EventEmitter` class is a core part of Node.js's event-driven architecture. It provides a way for objects to emit named events that trigger functions attached to those events."
    },
    {
      "id": 25,
      "question": "What is 'Piping' in Node.js streams?",
      "options": ["Connecting two databases", "Connecting the output of one stream to the input of another", "A method for creating a server", "A way to handle errors in streams"],
      "answer": "Connecting the output of one stream to the input of another",
      "explanation": "Piping is a mechanism that connects a readable stream to a writable stream, allowing data to flow from one to the other automatically."
    },
    {
      "id": 26,
      "question": "What is an 'error-first callback'?",
      "options": ["A function that always returns an error", "A callback function where the first argument is always an error object", "A method for debugging errors in Node.js", "A callback that handles errors only"],
      "answer": "A callback function where the first argument is always an error object",
      "explanation": "In Node.js, the 'error-first callback' is a common convention where the first argument of a callback function is reserved for an error object, and the second is for the result."
    },
    {
      "id": 27,
      "question": "What is the Reactor Pattern in Node.js?",
      "options": ["A design pattern for creating web servers", "A pattern for managing asynchronous I/O with an event loop", "A method for handling database connections", "A framework for building APIs"],
      "answer": "A pattern for managing asynchronous I/O with an event loop",
      "explanation": "The Reactor Pattern is an event-driven design for handling service requests that come in from multiple clients. It uses an event loop to handle requests and dispatch them to appropriate handlers."
    },
    {
      "id": 28,
      "question": "What is `libuv`?",
      "options": ["A JavaScript library", "A C++ library that provides the event loop and thread pool", "A Node.js module for security", "An npm package for file uploads"],
      "answer": "A C++ library that provides the event loop and thread pool",
      "explanation": "Libuv is a C++ library that provides the event loop, asynchronous I/O, and a thread pool. It is the engine that allows Node.js to perform its non-blocking operations."
    },
    {
      "id": 29,
      "question": "What is the difference between `spawn()` and `fork()` in the `child_process` module?",
      "options": ["`spawn` is for Node.js scripts, `fork` is for any command.", "`spawn` returns an object with IPC, `fork` does not.", "`fork` is a special case of `spawn` with IPC enabled.", "They are identical."],
      "answer": "`fork` is a special case of `spawn` with IPC enabled.",
      "explanation": "Both create a child process, but `fork()` is a specialized version of `spawn()` that is used to spawn new Node.js processes and establish an Inter-Process Communication (IPC) channel."
    },
    {
      "id": 30,
      "question": "How would you handle a CPU-intensive task in Node.js?",
      "options": ["Use a long-running synchronous function", "Use the `cluster` module or `Worker Threads`", "Use `setTimeout` to delay the task", "Run the task inside the main event loop"],
      "answer": "Use the `cluster` module or `Worker Threads`",
      "explanation": "CPU-intensive tasks can block the single-threaded event loop. Using the `cluster` module to create multiple processes or `Worker Threads` to run code on separate threads is the recommended approach to prevent this."
    }
  ]
}
